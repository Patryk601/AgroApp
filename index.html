<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>AgroApp – Mapa pól z Geoportalem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #fieldForm {
      display: none; position: absolute; bottom: 10px; left: 10px;
      background: white; padding: 10px; z-index: 9999; box-shadow: 0 2px 8px rgba(0,0,0,.15);
      border-radius: 8px; min-width: 260px; font-family: system-ui, sans-serif;
    }
    #fieldForm input[type="text"] { width: 100%; margin: 6px 0; padding: 6px 8px; }
    #fieldForm button { margin-top: 8px; padding: 8px 10px; cursor: pointer; }
    .field-label { font-weight: 600; background: rgba(255,255,255,.9); border-radius: 6px; padding: 2px 6px; }
    .leaflet-container { font-family: system-ui, sans-serif; }
  </style>
</head>
<body>

<div id="map"></div>

<div id="fieldForm">
  <input type="text" id="fieldName" placeholder="Nazwa pola" /><br />
  <input type="text" id="cropType" placeholder="Rodzaj uprawy" /><br />
  <input type="text" id="village" placeholder="Miejscowość" /><br />
  <label for="color">Kolor pola:</label>
  <input type="color" id="color" value="#4caf50" /><br />
  <p id="areaOutput">Powierzchnia: 0 ha</p>
  <button id="saveBtn" onclick="saveField()">Zapisz pole</button>
</div>

<!-- Leaflet + narzędzia -->
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.geometryutil/0.9.3/leaflet.geometryutil.min.js"></script>

<!-- Firebase v8 -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

<script>
/* =======================
   KONFIG – do edycji wg potrzeb
   ======================= */

// Kolejność: najpierw GetFeatureInfo, potem fallback do WFS.
const USE_WFS_FIRST = false;

// Jeśli używasz własnego proxy do obchodzenia CORS, wstaw URL, np. 'https://twoj-proxy.app/proxy?url='
const PROXY_URL = '';

// WMS/WFS Geoportalu
const WMS_EGIB_URL  = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/EGIB/MapServer/WMSServer';
const WFS_EGIB_URL  = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/EGIB/WFSServer';
const WMS_ORTO_URL  = 'https://mapy.geoportal.gov.pl/wss/service/PZGIK/ORTO/MapServer/WMSServer';
const PARCEL_LAYER  = 'dzialki';

/* =======================
   FIREBASE – Twoja konfiguracja
   ======================= */
const firebaseConfig = {
  apiKey: "AIzaSyAjzbeyCqqSg7KyM4NqGxQCrrxSz7rgC18",
  authDomain: "agroapp-1d397.firebaseapp.com",
  projectId: "agroapp-1d397",
  storageBucket: "agroapp-1d397.appspot.com",
  messagingSenderId: "683118014918",
  appId: "1:683118014918:web:aba19ec1b52fb12f142c7"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/* =======================
   UID z URL (?uid=...)
   ======================= */
const params = new URLSearchParams(window.location.search);
const userId = params.get("uid");
if (!userId) {
  alert("Brak identyfikatora użytkownika (?uid=...). Zapisy będą zablokowane.");
}

/* =======================
   Mapa – inicjalizacja
   ======================= */
const savedLat  = localStorage.getItem("mapLat");
const savedLng  = localStorage.getItem("mapLng");
const savedZoom = localStorage.getItem("mapZoom");
let startLat  = savedLat  ? parseFloat(savedLat)  : 51.25;
let startLng  = savedLng  ? parseFloat(savedLng)  : 22.57;
let startZoom = savedZoom ? parseInt(savedZoom)   : 12;

let drawnPolygon = null;
let highlightedLayer = null;
let drawnItems = new L.FeatureGroup();

const map = L.map('map', {
  center: [startLat, startLng],
  zoom: startZoom,
  layers: [] // dodamy poniżej
});

/* =======================
   Podkłady
   ======================= */
// OSM – startowa baza
const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
});

// Ortofotomapa GUGiK – WMS 1.1.1 + JPEG (ważne!)
const ortofotomapa = L.tileLayer.wms(WMS_ORTO_URL, {
  layers: 'Raster',
  version: '1.1.1',       // ArcGIS WMS woli 1.1.1
  format: 'image/jpeg',   // orto najlepiej w JPEG
  transparent: false,
  attribution: '&copy; Geoportal GUGiK',
  tileSize: 256
});

// Granice działek (nakładka)
const graniceDzialek = L.tileLayer.wms(WMS_EGIB_URL, {
  layers: 'dzialki,numery_dzialek',
  version: '1.3.0',
  format: 'image/png',
  transparent: true,
  attribution: '&copy; GUGiK'
});

/* =======================
   Dodanie warstw i kontrolki
   ======================= */
osmLayer.addTo(map);          // tylko jedna baza startowo
graniceDzialek.addTo(map);    // nakładka
map.addLayer(drawnItems);

L.control.layers(
  { "Ortofotomapa GUGiK": ortofotomapa, "OpenStreetMap": osmLayer },
  { "Działki ewidencyjne": graniceDzialek }
).addTo(map);

/* =======================
   Zapamiętywanie widoku
   ======================= */
map.on('moveend', function () {
  const c = map.getCenter();
  localStorage.setItem("mapLat", c.lat);
  localStorage.setItem("mapLng", c.lng);
  localStorage.setItem("mapZoom", map.getZoom());
});

/* =======================
   Rysowanie (opcjonalnie)
   ======================= */
const drawControl = new L.Control.Draw({
  draw: {
    polygon: true, rectangle: false, marker: false, polyline: false, circle: false, circlemarker: false
  },
  edit: { featureGroup: drawnItems, remove: true }
});
map.addControl(drawControl);

map.on('draw:created', function (e) {
  drawnPolygon = e.layer;
  drawnItems.addLayer(drawnPolygon);

  const area = L.GeometryUtil.geodesicArea(drawnPolygon.getLatLngs()[0]);
  const areaHa = (area / 10000).toFixed(2);
  const areaAr = (area / 100).toFixed(2);

  document.getElementById('areaOutput').innerText = `Powierzchnia: ${areaHa} ha (${areaAr} arów)`;
  document.getElementById('fieldForm').style.display = 'block';
  document.getElementById('fieldForm').dataset.parcelId = ''; // brak parcelId dla własnego rysunku
});

/* =======================
   Pomocnicze – proxy/URL
   ======================= */
function proxied(url) { return PROXY_URL ? PROXY_URL + encodeURIComponent(url) : url; }

function buildGetFeatureInfoUrl(latlng) {
  const point = map.latLngToContainerPoint(latlng, map.getZoom());
  const size  = map.getSize();
  const b     = map.getBounds();
  const sw    = b.getSouthWest();
  const ne    = b.getNorthEast();

  const params = {
    service: 'WMS',
    request: 'GetFeatureInfo',
    version: '1.3.0',
    layers: PARCEL_LAYER,
    query_layers: PARCEL_LAYER,
    styles: '',
    format: 'image/png',
    transparent: true,
    info_format: 'application/json',
    i: Math.round(point.x),
    j: Math.round(point.y),
    crs: 'EPSG:4326',
    bbox: [sw.lat, sw.lng, ne.lat, ne.lng].join(','),
    width: size.x,
    height: size.y
  };
  const q = Object.keys(params).map(k => `${k}=${encodeURIComponent(params[k])}`).join('&');
  return `${WMS_EGIB_URL}?${q}`;
}

/* =======================
   Wybór działki – klik
   ======================= */
map.on('click', async function(e) {
  try {
    if (USE_WFS_FIRST) {
      const ok = await selectParcelViaWFS(e.latlng);
      if (!ok) alert('Nie znaleziono działki w tym miejscu.');
      return;
    }

    // 1) GetFeatureInfo
    const gfiUrl = buildGetFeatureInfoUrl(e.latlng);
    let resp = await fetch(proxied(gfiUrl));
    if (!resp.ok) throw new Error('GetFeatureInfo HTTP ' + resp.status);

    let data = null;
    try { data = await resp.json(); } catch (_) { data = null; }

    if (!data || !data.features || !data.features.length || !data.features[0].geometry) {
      // 2) Fallback do WFS (gdy brak geometrii lub format inny niż JSON)
      const ok = await selectParcelViaWFS(e.latlng);
      if (!ok) alert('Nie znaleziono działki (GFI/WFS).');
      return;
    }

    showAndPrepareFeature(data.features[0]);

  } catch (err) {
    console.error('Błąd przy kliknięciu:', err);
    alert('Błąd pobierania działki (CORS lub błąd usługi). Rozważ użycie PROXY_URL.');
  }
});

/* =======================
   WFS – fallback / tryb główny
   ======================= */
async function selectParcelViaWFS(latlng) {
  const tol  = 0.00012; // ~10 m w stopniach
  const bbox = [latlng.lng - tol, latlng.lat - tol, latlng.lng + tol, latlng.lat + tol].join(',');
  const url  = `${WFS_EGIB_URL}?service=WFS&version=2.0.0&request=GetFeature&typename=${PARCEL_LAYER}` +
               `&bbox=${bbox},EPSG:4326&outputFormat=application/json`;

  const resp = await fetch(proxied(url));
  if (!resp.ok) return false;
  const gj = await resp.json();
  if (!gj.features || !gj.features.length) return false;

  showAndPrepareFeature(gj.features[0]);
  return true;
}

/* =======================
   Podświetlenie + powierzchnia
   ======================= */
function showAndPrepareFeature(feat) {
  const parcelId = feat.properties?.identyfikator || feat.properties?.id || feat.id || null;

  if (highlightedLayer) { map.removeLayer(highlightedLayer); highlightedLayer = null; }
  highlightedLayer = L.geoJSON(feat.geometry, {
    style: { color: '#ff6a00', weight: 3, fillOpacity: 0.15 }
  }).addTo(drawnItems);

  let area = 0;
  highlightedLayer.eachLayer(layer => {
    if (layer instanceof L.Polygon) {
      const rings = layer.getLatLngs();
      const firstRing = Array.isArray(rings[0]) ? rings[0] : rings;
      if (firstRing) area += L.GeometryUtil.geodesicArea(firstRing);
    }
  });
  const areaHa = (area / 10000).toFixed(2);
  const areaAr = (area / 100).toFixed(2);
  document.getElementById('areaOutput').innerText = `Powierzchnia: ${areaHa} ha (${areaAr} arów)`;

  const form = document.getElementById('fieldForm');
  form.style.display = 'block';
  form.dataset.parcelId = parcelId || '';
}

/* =======================
   Utils – koordynaty z warstwy
   ======================= */
function layerToFirstPolygonCoords(layer) {
  if (layer instanceof L.Polygon) {
    const rings = layer.getLatLngs();
    const firstRing = Array.isArray(rings[0]) ? rings[0] : rings;
    return firstRing.map(p => ({ lat: p.lat, lng: p.lng }));
  }
  let coords = [];
  layer.eachLayer(l => {
    if (l instanceof L.Polygon) {
      const rings = l.getLatLngs();
      const firstRing = Array.isArray(rings[0]) ? rings[0] : rings;
      coords = firstRing.map(p => ({ lat: p.lat, lng: p.lng }));
    }
  });
  return coords;
}

/* =======================
   Zapis pola do Firestore
   ======================= */
function saveField() {
  if (!userId) { alert('Brak uid – dodaj ?uid=... w URL.'); return; }

  let coords = [];
  if (highlightedLayer) {
    coords = layerToFirstPolygonCoords(highlightedLayer);
  } else if (drawnPolygon) {
    coords = drawnPolygon.getLatLngs()[0].map(p => ({ lat: p.lat, lng: p.lng }));
  } else {
    alert('Brak wybranego poligonu.');
    return;
  }

  const latlngs = coords.map(c => L.latLng(c.lat, c.lng));
  const area    = L.GeometryUtil.geodesicArea(latlngs);
  const areaHa  = area / 10000;
  const areaAr  = area / 100;

  let centerLat = 0, centerLng = 0;
  coords.forEach(c => { centerLat += c.lat; centerLng += c.lng; });
  centerLat /= coords.length; centerLng /= coords.length;

  const fieldData = {
    userId,
    name: document.getElementById("fieldName").value || null,
    crop: document.getElementById("cropType").value || null,
    village: document.getElementById("village").value || null,
    color: document.getElementById("color").value || "#4caf50",
    coordinates: coords,
    area_ha: areaHa,
    area_ar: areaAr,
    parcelId: document.getElementById('fieldForm').dataset.parcelId || null,
    created_at: firebase.firestore.FieldValue.serverTimestamp(),
    center_lat: centerLat,
    center_lng: centerLng
  };

  db.collection("fields").add(fieldData)
    .then(() => {
      alert("Pole zapisane!");
      document.getElementById("fieldForm").style.display = "none";
      drawnItems.clearLayers();
      highlightedLayer = null;
      drawnPolygon = null;
      location.reload();
    })
    .catch((error) => {
      console.error("Błąd zapisu: ", error);
      alert("Wystąpił błąd podczas zapisu pola.");
    });
}

/* =======================
   Wczytywanie pól użytkownika
   ======================= */
function loadFields() {
  if (!userId) return;
  db.collection("fields").where("userId", "==", userId).get()
    .then((snap) => {
      snap.forEach((doc) => {
        const d = doc.data();
        const polygon = L.polygon(d.coordinates.map(c => [c.lat, c.lng]), {
          color: d.color || "#4caf50"
        }).addTo(drawnItems);

        polygon.bindTooltip(d.name || '(bez nazwy)', {
          permanent: true, direction: "center", className: "field-label"
        });

        polygon.on('click', function () {
          document.getElementById('fieldName').value = d.name || '';
          document.getElementById('cropType').value  = d.crop || '';
          document.getElementById('village').value   = d.village || '';
          document.getElementById('color').value     = d.color || '#4caf50';
          document.getElementById('areaOutput').innerText =
            `Powierzchnia: ${(d.area_ha || 0).toFixed ? d.area_ha.toFixed(2) : (d.area_ha || 0)} ha (` +
            `${(d.area_ar || 0).toFixed ? d.area_ar.toFixed(2) : (d.area_ar || 0)} arów)`;
          const form = document.getElementById('fieldForm');
          form.style.display = 'block';
          form.dataset.parcelId = d.parcelId || '';
        });
      });
    });
}
loadFields();

/* =======================
   API dla Fluttera (opcjonalnie)
   ======================= */
window.centerMapFromFlutter = function(lat, lng) {
  if (map) map.setView([lat, lng], map.getZoom());
};
</script>
</body>
</html>
